#%%

import numpy as np
import pandas as pd
import yfinance as yf
import warnings
import requests
import riskfolio as rp
import urllib as urllib
from zipfile import ZipFile
import io
from io import StringIO
from io import BytesIO
from openpyxl import load_workbook

#########################################Parameters##########################################
Model='Classic' # Could be Classic (historical), BL (Black Litterman) or FM (Factor Model)
Rm = 'UCI' # Risk measure used, this time will be variance
Obj = 'Sharpe' # Objective function, could be MinRisk, MaxRet, Utility or Sharpe
Hist = True # Use historical scenarios for risk measures that depend on scenarios
Rf = 0 # Risk free rate
L = 1 # Risk aversion factor, only useful when obj is 'Utility'
Points = 50 # Number of points of the frontier
Start = '2022-01-01'
End = '2022-09-09'


warnings.filterwarnings("ignore")
pd.options.display.float_format = '{:.4%}'.format



# Downloading parameters
def excel_download():
    holdings_url = "https://github.com/ra6it/RiskParity/blob/main/RiskParity_Holdings.xlsx?raw=true"
    holdings_url = requests.get(holdings_url).content
    assets = pd.read_excel(holdings_url,usecols="A:B", engine='openpyxl')
    print(assets)
    assets = assets.reindex(columns=['Asset', 'Industry'])
    asset_classes = {'Asset': assets['Asset'].values.tolist(), 
                     'Industry': assets['Industry'].values.tolist()}
    asset_classes = pd.DataFrame(asset_classes)
    asset_classes = asset_classes.sort_values(by=['Asset'])
    asset = assets['Asset'].values.tolist()
    constraint_url = "https://github.com/ra6it/RiskParity/blob/main/RiskParity_Holdings.xlsx?raw=true"
    constraint_url = requests.get(constraint_url).content
    constraints = pd.read_excel(holdings_url,usecols="E:N", engine='openpyxl')
    constraints=pd.DataFrame(constraints)
    print("Constraints",constraints)
    prices = prices = yf.download(asset, start=Start, end=End)
    return asset_classes, constraints, prices
        
# Downloading data
def data_download(asset_classes):
    print("Downloading data...")
    asset = asset_classes['Asset'].to_string(index=False)
    data = yf.download(asset, start = Start, end = End)
    data = data.loc[:,('Adj Close', slice(None))]
    Y = data.pct_change().dropna()
    return Y
    
# Select method and estimate input parameters:
def method():
    method_mu='hist' # Method to estimate expected returns based on historical data.
    method_cov='hist' # Method to estimate covariance matrix based on historical data.
    return method_mu, method_cov

def portfolio_object(assets,method_mu, method_cov):
    Port = rp.Portfolio(returns=data_download(assets))
    Port.assets_stats(method_mu=method_mu, method_cov=method_cov, d=0.94)
    return Port

def create_pie(w):
    ax = rp.plot_pie(w=w, title='Sharpe Mean Variance', others=0.05, nrow=25, cmap = "tab20",
                 height=6, width=10, ax=None)

def constraints_weightings(constraints,asset_classes):
    asset_classes = pd.DataFrame(asset_classes)
    constraints = pd.DataFrame(constraints)
    data = constraints.fillna("")
    data = data.values.tolist()
    A, B = rp.assets_constraints(constraints, asset_classes)
    return A, B

def ainequality(A,B,Port):
    Port.ainequality = A
    Port.binequality = B
    w = Port.optimization(model=Model, rm=Rm, obj=Obj, rf=Rf, l=L, hist=Hist)
    print("Expected returns for", Start, "-", End,":",Port.mu)
    print("Holdings for", Start, "-", End,":", w.T)
    frontier_create(Port,w)

def frontier_create(Port,w):
    frontier = Port.efficient_frontier(model=Model, rm=Rm, points=Points, rf=Rf, hist=Hist)
    print(frontier.T.head())
    label = 'Max Risk Adjusted Return Portfolio' # Title of point
    mu = Port.mu # Expected returns
    cov = Port.cov # Covariance matrix
    returns = Port.returns # Returns of the assets
    ax = rp.plot_frontier(w_frontier=frontier, mu=mu, cov=cov, returns=returns, rm=Rm,
                      rf=Rf, alpha=0.05, cmap='viridis', w=w, label=label,
                      marker='*', s=16, c='r', height=6, width=10, ax=None)

############################################################
# Defining the backtest function 
############################################################

def backtest(datas, strategy, start, end, plot=False, **kwargs):
    cerebro = bt.Cerebro()

    # Here we add transaction costs and other broker costs
    cerebro.broker.setcash(1000000.0)
    cerebro.broker.setcommission(commission=0.005) # Commission 0.5%
    cerebro.broker.set_slippage_perc(0.005, # Slippage 0.5%
                                     slip_open=True,
                                     slip_limit=True,
                                     slip_match=True,
                                     slip_out=False)
    for data in datas:
        cerebro.adddata(data)

    # Here we add the indicators that we are going to store
    cerebro.addanalyzer(bt.analyzers.SharpeRatio, riskfreerate=0.0)
    cerebro.addanalyzer(bt.analyzers.Returns)
    cerebro.addanalyzer(bt.analyzers.DrawDown)
    cerebro.addstrategy(strategy, **kwargs)
    cerebro.addobserver(bt.observers.Value)
    cerebro.addobserver(bt.observers.DrawDown)
    results = cerebro.run(stdstats=False)
    if plot:
        cerebro.plot(iplot=False, start=start, end=end)
    return (results[0].analyzers.drawdown.get_analysis()['max']['drawdown'],
            results[0].analyzers.returns.get_analysis()['rnorm100'],
            results[0].analyzers.sharperatio.get_analysis()['sharperatio'])

def runner():
    asset_classes, constraints, prices = excel_download()
    method_mu, method_cov = method()
    Port = portfolio_object(asset_classes,method_mu, method_cov)
    A,B = constraints_weightings(constraints,asset_classes)
    ainequality(A,B,Port)
    returns(prices, asset_classes)

def returns(prices, asset_classes):
    pd.options.display.float_format = '{:.4%}'.format
    data = prices.loc[:, ('Adj Close', slice(None))]
    data.columns = asset_classes
    returner = data.pct_change().dropna()
    print(returner.head())
    rebalance_dates(returner)

def rebalance_dates(returner):
    index = returner.groupby([returner.index.year, returner.index.month]).tail(1).index
    index_2 = returner.index

    # Quarterly Dates
    index = [x for x in index if float(x.month) % 3.0 == 0 ] 

    # Dates where the strategy will be backtested
    index_ = [index_2.get_loc(x) for x in index if index_2.get_loc(x) > 1000]


############################################################
# Building the Buy and Hold strategy
############################################################

runner()
############################################################
# Run the backtest for the selected period
############################################################







# %%
